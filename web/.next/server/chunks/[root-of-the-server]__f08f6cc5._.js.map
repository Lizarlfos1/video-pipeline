{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///Users/jimmygrills/Documents/Coding/video-pipeline/web/lib/jobs.ts"],"sourcesContent":["import type { ChildProcess } from \"node:child_process\";\n\n/** In-memory job store for pipeline processes (single-user local tool) */\n\ninterface Job {\n  process: ChildProcess;\n  logs: string[];\n  status: \"running\" | \"done\" | \"error\";\n  listeners: Set<(data: string) => void>;\n}\n\nconst jobs = new Map<string, Job>();\n\nexport function getJob(jobId: string): Job | undefined {\n  return jobs.get(jobId);\n}\n\nexport function createJob(jobId: string, process: ChildProcess): Job {\n  const job: Job = {\n    process,\n    logs: [],\n    status: \"running\",\n    listeners: new Set(),\n  };\n  jobs.set(jobId, job);\n\n  process.stdout?.on(\"data\", (data: Buffer) => {\n    const line = data.toString();\n    job.logs.push(line);\n    for (const fn of job.listeners) {\n      fn(JSON.stringify({ type: \"log\", data: line }));\n    }\n  });\n\n  process.stderr?.on(\"data\", (data: Buffer) => {\n    const line = data.toString();\n    job.logs.push(line);\n    for (const fn of job.listeners) {\n      fn(JSON.stringify({ type: \"log\", data: line }));\n    }\n  });\n\n  process.on(\"close\", (code) => {\n    job.status = code === 0 ? \"done\" : \"error\";\n    for (const fn of job.listeners) {\n      fn(JSON.stringify({ type: job.status }));\n    }\n  });\n\n  return job;\n}\n\nexport function addListener(\n  jobId: string,\n  fn: (data: string) => void\n): () => void {\n  const job = jobs.get(jobId);\n  if (!job) return () => {};\n  job.listeners.add(fn);\n  return () => job.listeners.delete(fn);\n}\n"],"names":[],"mappings":";;;;;;;;AAWA,MAAM,OAAO,IAAI;AAEV,SAAS,OAAO,KAAa;IAClC,OAAO,KAAK,GAAG,CAAC;AAClB;AAEO,SAAS,UAAU,KAAa,EAAE,OAAqB;IAC5D,MAAM,MAAW;QACf;QACA,MAAM,EAAE;QACR,QAAQ;QACR,WAAW,IAAI;IACjB;IACA,KAAK,GAAG,CAAC,OAAO;IAEhB,QAAQ,MAAM,EAAE,GAAG,QAAQ,CAAC;QAC1B,MAAM,OAAO,KAAK,QAAQ;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC;QACd,KAAK,MAAM,MAAM,IAAI,SAAS,CAAE;YAC9B,GAAG,KAAK,SAAS,CAAC;gBAAE,MAAM;gBAAO,MAAM;YAAK;QAC9C;IACF;IAEA,QAAQ,MAAM,EAAE,GAAG,QAAQ,CAAC;QAC1B,MAAM,OAAO,KAAK,QAAQ;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC;QACd,KAAK,MAAM,MAAM,IAAI,SAAS,CAAE;YAC9B,GAAG,KAAK,SAAS,CAAC;gBAAE,MAAM;gBAAO,MAAM;YAAK;QAC9C;IACF;IAEA,QAAQ,EAAE,CAAC,SAAS,CAAC;QACnB,IAAI,MAAM,GAAG,SAAS,IAAI,SAAS;QACnC,KAAK,MAAM,MAAM,IAAI,SAAS,CAAE;YAC9B,GAAG,KAAK,SAAS,CAAC;gBAAE,MAAM,IAAI,MAAM;YAAC;QACvC;IACF;IAEA,OAAO;AACT;AAEO,SAAS,YACd,KAAa,EACb,EAA0B;IAE1B,MAAM,MAAM,KAAK,GAAG,CAAC;IACrB,IAAI,CAAC,KAAK,OAAO,KAAO;IACxB,IAAI,SAAS,CAAC,GAAG,CAAC;IAClB,OAAO,IAAM,IAAI,SAAS,CAAC,MAAM,CAAC;AACpC","debugId":null}},
    {"offset": {"line": 103, "column": 0}, "map": {"version":3,"sources":["file:///Users/jimmygrills/Documents/Coding/video-pipeline/web/app/api/pipeline/%5Bstage%5D/stream/route.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { getJob, addListener } from \"@/lib/jobs\";\n\nexport async function GET(request: NextRequest) {\n  const jobId = request.nextUrl.searchParams.get(\"jobId\");\n  if (!jobId) {\n    return new Response(\"Missing jobId\", { status: 400 });\n  }\n\n  const job = getJob(jobId);\n  if (!job) {\n    return new Response(\"Job not found\", { status: 404 });\n  }\n\n  const encoder = new TextEncoder();\n\n  const stream = new ReadableStream({\n    start(controller) {\n      // Send existing logs\n      for (const log of job.logs) {\n        controller.enqueue(\n          encoder.encode(`data: ${JSON.stringify({ type: \"log\", data: log })}\\n\\n`)\n        );\n      }\n\n      // If already finished, send final status\n      if (job.status !== \"running\") {\n        controller.enqueue(\n          encoder.encode(`data: ${JSON.stringify({ type: job.status })}\\n\\n`)\n        );\n        controller.close();\n        return;\n      }\n\n      // Listen for new events\n      const cleanup = addListener(jobId, (data) => {\n        try {\n          controller.enqueue(encoder.encode(`data: ${data}\\n\\n`));\n          const parsed = JSON.parse(data);\n          if (parsed.type === \"done\" || parsed.type === \"error\") {\n            controller.close();\n            cleanup();\n          }\n        } catch {\n          controller.enqueue(\n            encoder.encode(`data: ${JSON.stringify({ type: \"log\", data })}\\n\\n`)\n          );\n        }\n      });\n    },\n  });\n\n  return new Response(stream, {\n    headers: {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n    },\n  });\n}\n"],"names":[],"mappings":";;;;AACA;;AAEO,eAAe,IAAI,OAAoB;IAC5C,MAAM,QAAQ,QAAQ,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;IAC/C,IAAI,CAAC,OAAO;QACV,OAAO,IAAI,SAAS,iBAAiB;YAAE,QAAQ;QAAI;IACrD;IAEA,MAAM,MAAM,IAAA,8HAAM,EAAC;IACnB,IAAI,CAAC,KAAK;QACR,OAAO,IAAI,SAAS,iBAAiB;YAAE,QAAQ;QAAI;IACrD;IAEA,MAAM,UAAU,IAAI;IAEpB,MAAM,SAAS,IAAI,eAAe;QAChC,OAAM,UAAU;YACd,qBAAqB;YACrB,KAAK,MAAM,OAAO,IAAI,IAAI,CAAE;gBAC1B,WAAW,OAAO,CAChB,QAAQ,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;oBAAE,MAAM;oBAAO,MAAM;gBAAI,GAAG,IAAI,CAAC;YAE5E;YAEA,yCAAyC;YACzC,IAAI,IAAI,MAAM,KAAK,WAAW;gBAC5B,WAAW,OAAO,CAChB,QAAQ,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;oBAAE,MAAM,IAAI,MAAM;gBAAC,GAAG,IAAI,CAAC;gBAEpE,WAAW,KAAK;gBAChB;YACF;YAEA,wBAAwB;YACxB,MAAM,UAAU,IAAA,mIAAW,EAAC,OAAO,CAAC;gBAClC,IAAI;oBACF,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC;oBACrD,MAAM,SAAS,KAAK,KAAK,CAAC;oBAC1B,IAAI,OAAO,IAAI,KAAK,UAAU,OAAO,IAAI,KAAK,SAAS;wBACrD,WAAW,KAAK;wBAChB;oBACF;gBACF,EAAE,OAAM;oBACN,WAAW,OAAO,CAChB,QAAQ,MAAM,CAAC,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;wBAAE,MAAM;wBAAO;oBAAK,GAAG,IAAI,CAAC;gBAEvE;YACF;QACF;IACF;IAEA,OAAO,IAAI,SAAS,QAAQ;QAC1B,SAAS;YACP,gBAAgB;YAChB,iBAAiB;YACjB,YAAY;QACd;IACF;AACF","debugId":null}}]
}